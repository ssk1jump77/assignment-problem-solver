\documentclass[a4paper,14pt]{extarticle}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{geometry}
\geometry{left=3cm,right=1.5cm,top=2cm,bottom=2cm}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{tocloft}
\usepackage{array}
\usepackage{longtable}
\usepackage{float}
\usepackage{caption}
\usepackage{setspace}
\singlespacing

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}

\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\addto\captionsrussian{\renewcommand{\contentsname}{ОГЛАВЛЕНИЕ}}

\begin{document}

\begin{titlepage}
\centering
МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ

ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ АВТОНОМНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ

«САНКТ-ПЕТЕРБУРГСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ АЭРОКОСМИЧЕСКОГО ПРИБОРОСТРОЕНИЯ»

\vspace{1cm}
Кафедра инфокоммуникационных технологий и систем связи

\vspace{2cm}
{\Large \textbf{КУРСОВАЯ РАБОТА}}

\vspace{0.5cm}
{\large \textbf{«Задача о назначениях»}}

\vspace{1.5cm}
\begin{minipage}[t]{0.4\textwidth}
\raggedright
\textbf{ЗАЩИЩЕНА С ОЦЕНКОЙ} \\
\\
\textbf{РУКОВОДИТЕЛЬ:} \\
ассистент \\
\underline{\hspace{3cm}} \\
подпись, дата \\
\\
\textbf{РАБОТУ ВЫПОЛНИЛ:} \\
СТУДЕНТ гр. № 2451 \\
\underline{\hspace{3cm}} \\
подпись, дата
\end{minipage}
\hfill
\begin{minipage}[t]{0.4\textwidth}
\raggedleft
\\
\\
\\
А.Н. Головенков \\
инициалы, фамилия \\
\\
\\
\\
\\
\\
Н.С. Захаров \\
инициалы, фамилия
\end{minipage}

\vspace{2cm}
\begin{center}
\begin{tabular}{|c|}
\hline
ОТЧЕТ ПО КУРСОВОЙ РАБОТЕ \\
\hline
«ЗАДАЧА О НАЗНАЧЕНИЯХ» \\
\hline
\# \\
\hline
по курсу: ОСНОВЫ ПРОГРАММИРОВАНИЯ \\
\hline
\#\#\# \\
\hline
\\
\hline
\end{tabular}
\end{center}

\vfill
Санкт-Петербург \\
2025
\end{titlepage}

\tableofcontents
\newpage

\section*{ВВЕДЕНИЕ}
\addcontentsline{toc}{section}{ВВЕДЕНИЕ}

Задача о назначениях представляет собой одну из фундаментальных проблем дискретной оптимизации с широким спектром практических применений. Её сущность заключается в поиске оптимального распределения исполнителей по работам при заданных стоимостях выполнения каждой операции. Эта задача регулярно возникает в экономике, управлении производством, логистике и планировании, где требуется эффективно использовать ограниченные ресурсы для минимизации общих затрат. Простота формулировки в сочетании с нетривиальностью решения делает задачу о назначениях идеальным объектом для изучения различных подходов к разработке алгоритмов.

В образовательном контексте реализация алгоритмов для задачи о назначениях позволяет продемонстрировать ключевые концепции программирования и анализа сложности. Полный перебор всех возможных вариантов назначений служит наглядной иллюстрацией факториального роста вычислительных затрат, характерного для многих комбинаторных задач. Жадный алгоритм, строящий решение на основе последовательных локально оптимальных выборов, показывает, как можно получать практически полезные результаты за приемлемое время, хотя и без гарантий абсолютной оптимальности.

Данная курсовая работа посвящена разработке программной реализации обоих алгоритмов и их сравнительному анализу. Исследование включает создание модульной системы на языке C++ с использованием объектно-ориентированного подхода, стандартных библиотечных контейнеров и механизма обработки аргументов командной строки. Особое внимание уделяется корректности реализации, читаемости кода и соответствию современным стандартам разработки программного обеспечения. Практическая часть работы включает тестирование алгоритмов на серии контрольных примеров различной размерности, анализ производительности и оценку качества получаемых решений.

\section*{ПОСТАНОВКА ЗАДАЧИ}
\addcontentsline{toc}{section}{ПОСТАНОВКА ЗАДАЧИ}

Цель курсовой работы --- разработка программного обеспечения для решения классической задачи о назначениях с использованием двух принципиально различных алгоритмических подходов и проведение сравнительного анализа их эффективности.

Алгоритм полного перебора реализован с использованием рекурсивного поиска с отсечением неперспективных ветвей, что позволяет эффективно обрабатывать задачи размерностью до n=10. Жадный алгоритм применяет стратегию выбора минимальной стоимости для каждого работника среди ещё не назначенных работ. Оценка качества решения осуществляется путём сравнения общей стоимости полученного назначения с оптимальным значением (для небольших задач) или с нижней границей стоимости.

Требования к реализации программы: обеспечить загрузку матрицы стоимостей из текстового файла, выполнение вычислений в соответствии с выбранным алгоритмом, сохранение результатов назначений и общей стоимости в выходной файл, а также использование аргументов командной строки для задания параметров ввода. Реализация должна быть выполнена в объектно-ориентированном стиле с использованием контейнеров стандартной библиотеки STL. Необходимо обеспечить корректную реализацию обоих алгоритмов, обработку входных данных и вывод результатов.

\section{АЛГОРИТМ ПОЛНОГО ПЕРЕБОРА}
\addcontentsline{toc}{section}{АЛГОРИТМ ПОЛНОГО ПЕРЕБОРА}

\subsection{Основные идеи алгоритма}

\begin{enumerate}
\item \textbf{Биективное соответствие как перестановка:} каждое возможное назначение работников на работы интерпретируется как перестановка $\pi$ множества $\{1, 2, \ldots, n\}$, где $\pi(i) = j$ означает, что i-й работник назначается на j-ю работу. Таким образом, пространство решений задачи составляет ровно $n!$ различных перестановок.

\item \textbf{Исчерпывающий перебор с использованием стандартной библиотеки:} Алгоритм генерирует все возможные перестановки с помощью стандартной функции \texttt{std::next\_permutation} из библиотеки \texttt{<algorithm>}, которая последовательно генерирует лексикографически возрастающие перестановки начальной последовательности $\{1, 2, \ldots, n\}$.

\item \textbf{Треккинг оптимального решения:} в процессе перебора поддерживаются две переменные: текущее минимальное значение стоимости (\texttt{bestCost}) и соответствующая ему перестановка (\texttt{bestAssignment}). Каждая вновь вычисленная стоимость сравнивается с текущим минимумом, и при нахождении лучшего решения обновляются обе переменные.

\item \textbf{Отсутствие эвристик и элиминаций:} в отличие от оптимизированных алгоритмов (таких как метод ветвей и границ или венгерский алгоритм), данный подход не использует никаких эвристик для сокращения пространства поиска. Это гарантирует, что ни одно потенциально оптимальное решение не будет пропущено, но приводит к экспоненциальному росту вычислительных затрат.

\item \textbf{Автоматический учет ограничений задачи:} поскольку каждая перестановка по определению представляет биективное соответствие, автоматически удовлетворяются все ограничения задачи: каждый работник назначается ровно на одну работу, и каждая работа выполняется ровно одним работником. Это избавляет алгоритм от необходимости явной проверки допустимости решений.
\end{enumerate}

\subsection{Шаги алгоритма}

Алгоритм полного перебора реализуется в шесть последовательных этапов:

\textbf{Шаг 1. Подготовка начальных данных.} Формируется исходная перестановка чисел от 0 до n-1, где позиция элемента определяет работника, а значение --- назначаемую работу. Инициализируются переменные для хранения оптимального решения и счетчиков.

\textbf{Шаг 2. Предварительный анализ.} Вычисляется общее количество перестановок n! и выводится предупреждение при $n > 10$ о непрактичности алгоритма для больших размерностей.

\textbf{Шаг 3. Систематический перебор всех перестановок.} С помощью стандартной библиотечной функции последовательно генерируются все n! перестановок в лексикографическом порядке. Для каждой перестановки выполняется полный цикл проверки.

\textbf{Шаг 4. Оценка каждой перестановки.} Для текущей перестановки вычисляется суммарная стоимость назначения путем суммирования соответствующих элементов матрицы. Полученное значение сравнивается с текущим лучшим результатом.

\textbf{Шаг 5. Обновление оптимального решения.} При обнаружении перестановки с меньшей суммарной стоимостью происходит сохранение нового оптимального назначения и соответствующего значения стоимости.

\textbf{Шаг 6. Формирование итогового результата.} После перебора всех вариантов возвращается оптимальное назначение и минимальная стоимость. При необходимости выводится статистика о количестве проверенных перестановок и времени выполнения.

\subsection{Псевдокод алгоритма}

\begin{lstlisting}[caption={Алгоритм полного перебора}, label={lst:brute_force}, language=C++, basicstyle=\small\ttfamily]
Input: input_file - текстовый файл с размером N и матрицей стоимостей N×N
Output: В консоль выводятся результаты обоих алгоритмов; в файл result.txt сохраняется полный отчет.

function factorial(n): /* --- Вычисление факториала --- */
    result ← 1
    for i от 2 до n:
        result ← result × i
    return result

function bruteForce(costMatrix, n): /* --- Алгоритм полного перебора --- */
    permutation ← [0, 1, 2, ..., n-1] /* начальная перестановка */
    bestCost ← ∞
    bestAssignment ← permutation
    totalPermutations ← factorial(n)
    checked ← 0
    
    if n > 10: /* --- Предупреждение о большом размере --- */
        print "Warning: matrix size", n, "is too large for brute force"
        return (bestAssignment, bestCost)
    
    print "Brute force: checking", totalPermutations, "permutations..."
    
    do:
        checked ← checked + 1
        
        /* Вычисление стоимости текущей перестановки */
        currentCost ← 0
        for i от 0 до n-1:
            currentCost ← currentCost + costMatrix[i][permutation[i]]
        
        /* Обновление лучшего решения */
        if currentCost < bestCost:
            bestCost ← currentCost
            bestAssignment ← копия(permutation)
        
        /* Вывод прогресса для больших матриц */
        if n ≥ 5 и checked mod 10000 = 0:
            print "Progress:", checked, "/", totalPermutations
    
    while next_permutation(permutation) = true /* Стандартная библиотечная функция */
    
    print "Checked", checked, "permutations"
    return (bestAssignment, bestCost)
\end{lstlisting}

\subsection{Блок-схема алгоритма}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{media/image1.png}
\caption{Блок-схема алгоритма полного перебора}
\label{fig:brute_force_flowchart}
\end{figure}

\subsection{Пошаговое выполнение на примере}

Рассмотрим работу алгоритма полного перебора на конкретном примере матрицы стоимостей размером 3×3:

\textbf{Исходные данные:}

Матрица стоимостей C (3×3):

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
 & Работа 1 & Работа 2 & Работа 3 \\
\hline
Работник 1 & 9 & 2 & 7 \\
Работник 2 & 6 & 4 & 3 \\
Работник 3 & 5 & 8 & 1 \\
\hline
\end{tabular}
\end{center}

\texttt{output.txt:}
\begin{verbatim}
3
9 2 7
6 4 3
5 8 1
\end{verbatim}

\textbf{Шаг 1: Инициализация}

Создаётся начальная перестановка: $\pi = [0, 1, 2]$ \\
(Работник1→Работа1, Работник2→Работа2, Работник3→Работа3) \\
Инициализируются переменные: \texttt{bestCost} = $\infty$, \texttt{bestAssignment} = $[0, 1, 2]$ \\
Вычисляется общее число перестановок: $3! = 6$

\textbf{Шаг 2: Перебор первой перестановки $[0, 1, 2]$}

Вычисление стоимости: $C[0][0] + C[1][1] + C[2][2] = 9 + 4 + 1 = 14$ \\
Сравнение: $14 < \infty$ → обновление \\
Теперь: \texttt{bestCost} = $14$, \texttt{bestAssignment} = $[0, 1, 2]$

\textbf{Шаг 3: Вторая перестановка $[0, 2, 1]$ (генерация next\_permutation)}

Назначение: Работник1 → Работа1, Работник2 → Работа3, Работник3 → Работа2 \\
Вычисление стоимости: $C[0][1] + C[1][0] + C[2][2] = 2 + 6 + 1 = 9$ \\
Сравнение: $9 < 14$ → обновление \\
Теперь: \texttt{bestCost} = $9$, \texttt{bestAssignment} = $[1, 0, 2]$

\textbf{Шаг 4: Третья перестановка $[1, 0, 2]$}

Назначение: Работник1 → Работа2, Работник2 → Работа1, Работник3 → Работа3 \\
Вычисление стоимости: $C[0][1] + C[1][0] + C[2][2] = 2 + 6 + 1 = 9$ \\
Сравнение: $9 = 9$ → без изменений

\textbf{Шаг 5: Четвёртая перестановка $[1, 2, 0]$}

Назначение: Работник1 → Работа2, Работник2 → Работа3, Работник3 → Работа1 \\
Вычисление стоимости: $C[0][1] + C[1][2] + C[2][0] = 2 + 3 + 5 = 10$ \\
Сравнение: $10 > 9$ → без изменений

\textbf{Шаг 6: Пятая перестановка $[2, 0, 1]$}

Назначение: Работник1 → Работа3, Работник2 → Работа1, Работник3 → Работа2 \\
Вычисление стоимости: $C[0][2] + C[1][0] + C[2][1] = 7 + 6 + 8 = 21$ \\
Сравнение: $21 > 9$ → без изменений

\textbf{Шаг 7: Шестая перестановка $[2, 1, 0]$}

Назначение: Работник1 → Работа3, Работник2 → Работа2, Работник3 → Работа1 \\
Вычисление стоимости: $C[0][2] + C[1][1] + C[2][0] = 7 + 4 + 5 = 16$ \\
Сравнение: $16 > 9$ → без изменений

\textbf{Шаг 8: Завершение перебора}

Все 6 перестановок проверены. Алгоритм завершает работу.

\subsection{Структуры данных}

Для реализации алгоритма полного перебора в задаче о назначениях используются следующие структуры данных:

\begin{itemize}
\item \textbf{Основная матрица стоимостей:} \texttt{std::vector<std::vector<int>> costMatrix;}

Тип: двумерный динамический массив (вектор векторов) \\
Назначение: хранение квадратной матрицы стоимостей размерности n×n \\
Преимущества: автоматическое управление памятью, динамическое изменение размера, прямой доступ к элементам за O(1) \\
Размер: n × n элементов типа int

\item \textbf{Счетчики и метаданные:}

\texttt{long long totalPermutations;} // Общее число перестановок n! \\
\texttt{long long checkedPermutations;} // Количество проверенных перестановок \\
\texttt{int n;} // Размерность задачи

Типы: long long для больших значений факториала
\end{itemize}

\subsection{Анализ сложности}

\textbf{Временная сложность:} $O(n \cdot n!)$ \\
$n!$ перестановок для проверки \\
$n$ операций для вычисления стоимости каждой перестановки \\

Пример: для $n=10$ → 36 млн операций ($\sim$0.3 сек), для $n=12$ → 5.7 млрд операций ($\sim$1 минута)

\textbf{Пространственная сложность:} $O(n^2)$ \\
Матрица стоимостей: $n \times n$ элементов \\
Дополнительные векторы: $2 \times n$ элементов \\
Пример: для $n=10$ → $\sim$500 байт

\textbf{Практические ограничения:}
\begin{itemize}
\item $n \leq 8$ - приемлемое время ($< 0.1$ сек)
\item $n = 9-10$ - секундное ожидание
\item $n \geq 11$ - непрактично (минуты и более)
\end{itemize}

\textbf{Особенности:}
\begin{itemize}
\item Все случаи одинаковы (нет лучшего/худшего)
\item Нет оптимизаций (чистый перебор)
\item Гарантированная оптимальность решения
\end{itemize}

\section{ЖАДНЫЙ АЛГОРИТМ}
\addcontentsline{toc}{section}{ЖАДНЫЙ АЛГОРИТМ}

\subsection{Основные идеи алгоритма}

\begin{enumerate}
\item \textbf{Локально оптимальный выбор:} на каждом шаге алгоритм выбирает для текущего работника работу с минимальной стоимостью среди ещё не занятых работ. Принцип "жадности" заключается в том, что на каждом этапе принимается решение, наилучшее в данный момент, без учёта будущих последствий.

\item \textbf{Последовательное назначение:} Алгоритм обрабатывает работников в фиксированном порядке (обычно от 1 до n). Для каждого работника выполняется поиск минимальной стоимости среди всех доступных работ, после чего выбранная работа помечается как занятая и исключается из дальнейшего рассмотрения.

\item \textbf{Накопительная стратегия:} Общая стоимость решения формируется как сумма локально минимальных стоимостей, найденных на каждом шаге. Алгоритм не пересматривает принятые ранее решения даже если они оказываются неоптимальными в глобальном контексте.

\item \textbf{Эффективность за счёт приближённости:} В отличие от полного перебора, жадный алгоритм жертвует гарантией оптимальности в обмен на полиномиальную сложность. Это позволяет решать задачи значительной размерности за приемлемое время.

\item \textbf{Автоматический учет ограничений задачи:} поскольку каждая перестановка по определению представляет биективное соответствие, автоматически удовлетворяются все ограничения задачи: каждый работник назначается ровно на одну работу, и каждая работа выполняется ровно одним работником. Это избавляет алгоритм от необходимости явной проверки допустимости решений.
\end{enumerate}

\subsection{Шаги алгоритма}

\textbf{Шаг 1. Инициализация.} Создание массива флагов \texttt{usedJobs[n]}, инициализированного false (все работы свободны). Создание результирующего массива \texttt{assignment[n]} для хранения назначений. Инициализация переменной \texttt{totalCost = 0}.

\textbf{Шаг 2. Последовательная обработка работников.} Цикл по всем работникам от 0 до n-1: для текущего работника worker выполняются шаги 3-5.

\textbf{Шаг 3. Поиск минимальной свободной работы.} Инициализация: \texttt{minCost = $\infty$}, \texttt{bestJob = -1}. Цикл по всем работам от 0 до n-1: если работа job не занята (\texttt{usedJobs[job] == false}) и стоимость \texttt{costMatrix[worker][job] < minCost}. Тогда обновить: \texttt{minCost = costMatrix[worker][job]}, \texttt{bestJob = job}.

\textbf{Шаг 4. Назначение найденной работы.} Если найдена подходящая работа (\texttt{bestJob $\neq$ -1}): \texttt{assignment[worker] = bestJob}, \texttt{usedJobs[bestJob] = true}, \texttt{totalCost += minCost}.

\textbf{Шаг 5. Переход к следующему работнику.} Переход к шагу 2 для следующего работника.

\textbf{Шаг 6. Формирование результата.} Возврат структуры с: массивом назначений \texttt{assignment}, суммарной стоимостью \texttt{totalCost}.

\subsection{Псевдокод алгоритма}

\begin{lstlisting}[caption={Жадный алгоритм}, label={lst:greedy}, language=C++, basicstyle=\small\ttfamily]
Вход: матрица стоимостей C[n][n]
Выход: назначение assignment[n], общая стоимость totalCost

function greedyAssignment(costMatrix, n): /* --- Жадный алгоритм --- */
    /* Шаг 1: Инициализация */
    usedJobs ← массив размером n, заполненный false /* флаги занятости работ */
    assignment ← массив размером n /* результирующее назначение */
    totalCost ← 0 /* суммарная стоимость */
    
    /* Шаг 2: Последовательная обработка работников */
    for worker от 0 до n-1:
        /* Шаг 3: Поиск минимальной свободной работы */
        bestJob ← -1 /* лучшая работа для работника */
        minCost ← ∞ /* минимальная стоимость */
        
        for job от 0 до n-1:
            if not usedJobs[job] и costMatrix[worker][job] < minCost:
                minCost ← costMatrix[worker][job]
                bestJob ← job
        
        /* Шаг 4: Назначение найденной работы */
        if bestJob ≠ -1:
            assignment[worker] ← bestJob
            usedJobs[bestJob] ← true
            totalCost ← totalCost + minCost
    
    /* Шаг 6: Формирование результата */
    return (assignment, totalCost)
\end{lstlisting}

\subsection{Блок-схема алгоритма}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{media/image2.png}
\caption{Блок-схема жадного алгоритма}
\label{fig:greedy_flowchart}
\end{figure}

\subsection{Пошаговое выполнение алгоритма на примере}

Рассмотрим работу жадного алгоритма на том же примере матрицы 3×3:

Матрица стоимостей:

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
 & Работа 1 & Работа 2 & Работа 3 \\
\hline
Работник 1 & 9 & 2 & 7 \\
Работник 2 & 6 & 4 & 3 \\
Работник 3 & 5 & 8 & 1 \\
\hline
\end{tabular}
\end{center}

\textbf{Инициализация:}

\texttt{usedJobs = [false, false, false]} (все работы свободны) \\
\texttt{assignment = [?, ?, ?]} (ещё не назначено) \\
\texttt{totalCost = 0}

\textbf{Шаг 1: Обработка Работника 1 (W1)}

Поиск минимальной свободной работы:
\begin{itemize}
\item Работа J1: стоимость 9 (свободна)
\item Работа J2: стоимость 2 (свободна) ← минимальная!
\item Работа J3: стоимость 7 (свободна)
\end{itemize}

Результат: \texttt{bestJob = 1} (J2), \texttt{minCost = 2} \\
\texttt{assignment[0] = 1} (W1→J2) \\
\texttt{usedJobs = [false, true, false]} (J2 занята) \\
\texttt{totalCost = 0 + 2 = 2}

\textbf{Шаг 2: Обработка Работника 2 (W2)}

Поиск минимальной свободной работы:
\begin{itemize}
\item Работа J1: стоимость 6 (свободна)
\item Работа J2: стоимость 4 (занята!) - пропускаем
\item Работа J3: стоимость 3 (свободна) ← минимальная!
\end{itemize}

Результат: \texttt{bestJob = 2} (J3), \texttt{minCost = 3} \\
\texttt{assignment[1] = 2} (W2→J3) \\
\texttt{usedJobs = [false, true, true]} (J2 и J3 заняты) \\
\texttt{totalCost = 2 + 3 = 5}

\textbf{Шаг 3: Обработка Работника 3 (W3)}

Поиск минимальной свободной работы:
\begin{itemize}
\item Работа J1: стоимость 5 (свободна) ← единственная доступная!
\item Работа J2: стоимость 8 (занята) - пропускаем
\item Работа J3: стоимость 1 (занята) - пропускаем
\end{itemize}

Результат: \texttt{bestJob = 0} (J1), \texttt{minCost = 5} \\
\texttt{assignment[2] = 0} (W3→J1) \\
\texttt{usedJobs = [true, true, true]} (все работы заняты) \\
\texttt{totalCost = 5 + 5 = 10}

\textbf{Итоговое решение:}

Назначение:
\begin{itemize}
\item Работник 1 → Работа 2 (стоимость: 2)
\item Работник 2 → Работа 3 (стоимость: 3)
\item Работник 3 → Работа 1 (стоимость: 5)
\end{itemize}
Общая стоимость: $2 + 3 + 5 = 10$.

\subsection{Структуры данных}

\begin{itemize}
\item \textbf{Основная матрица стоимостей:} \texttt{std::vector<std::vector<int>> costMatrix;}
\item \textbf{Массив флагов занятости работ:} \texttt{std::vector<bool> usedJobs;}
\item \textbf{Результирующее назначение:} \texttt{std::vector<int> assignment;}
\end{itemize}

\subsection{Анализ сложности алгоритма}

\textbf{Временная сложность:} $O(n^2)$ \\
Внешний цикл: $n$ итераций (по работникам) \\
Внутренний цикл: $n$ итераций (по работам) \\
Итого: $n \times n = n^2$ основных операций

$T(n) = n \times (n \text{ сравнений} + n \text{ проверок доступности} + 1 \text{ обновление}) \approx 2n^2$ операций $= O(n^2)$

\section{СРАВНИТЕЛЬНЫЙ АНАЛИЗ АЛГОРИТМОВ}
\addcontentsline{toc}{section}{СРАВНИТЕЛЬНЫЙ АНАЛИЗ АЛГОРИТМОВ}

\subsection{Теоретическое сравнение}

Сравнительные характеристики алгоритмов полного перебора и жадного алгоритма представлены в таблице 1, где систематизированы их ключевые теоретические параметры.

\begin{table}[H]
\centering
\caption{Теоретическое сравнение алгоритмов решения задачи о назначениях}
\begin{tabular}{|p{6cm}|p{6cm}|p{6cm}|}
\hline
\textbf{Параметр сравнения} & \textbf{Алгоритм полного перебора} & \textbf{Жадный алгоритм} \\
\hline
\textbf{Тип алгоритма} & Точный (exact) & Приближённый (approximate) \\
\hline
\textbf{Гарантия оптимальности} & Гарантирует глобальный оптимум & Нет гарантии, локальный оптимум \\
\hline
\textbf{Временная сложность} & $O(n \cdot n!)$ - факториальная & $O(n^2)$ - полиномиальная \\
\hline
\textbf{Пространственная сложность} & $O(n^2)$ - полиномиальная & $O(n^2)$ - полиномиальная \\
\hline
\textbf{Принцип работы} & Перебор всех n! перестановок & Последовательный локально оптимальный выбор \\
\hline
\textbf{Детерминированность} & Всегда одинаковый результат & Зависит от порядка работников \\
\hline
\textbf{Критерий остановки} & Проверены все варианты & Назначены все работники \\
\hline
\end{tabular}
\end{table}

\textbf{Ключевые теоретические различия:}
\begin{itemize}
\item Полный перебор имеет экспоненциальную сложность, жадный - полиномиальную
\item Полный перебор гарантирует оптимальность, жадный - быстроту
\item Полный перебор исчерпывающий, жадный - эвристический
\end{itemize}

\subsection{Практические результаты}

Экспериментальные данные на тестовых матрицах:

\textbf{Тест 1:} Матрица 3×3
\begin{verbatim}
9 2 7
6 4 3
5 8 1
\end{verbatim}
\textbf{Результаты:}
\begin{itemize}
\item Полный перебор: стоимость = 9 (оптимально)
\item Жадный алгоритм: стоимость = 10
\item Отклонение: +11.1\%
\end{itemize}

\textbf{Тест 2:} Матрица 4×4
\begin{verbatim}
82 83 69 92
77 37 49 92
11 69 5 86
8 9 98 23
\end{verbatim}
\textbf{Результаты:}
\begin{itemize}
\item Полный перебор: стоимость = 140 (оптимально)
\item Жадный алгоритм: стоимость = 140
\item Отклонение: 0.0\%
\end{itemize}

\textbf{Тест 3:} Матрица 5×5
\begin{verbatim}
12 7 9 7 9
8 9 6 6 6
7 17 12 14 9
15 14 6 6 10
4 10 7 10 9
\end{verbatim}
\textbf{Результаты:}
\begin{itemize}
\item Полный перебор: стоимость = 32 (оптимально)
\item Жадный алгоритм: стоимость = 35
\item Отклонение: +9.1\%
\end{itemize}

В тестовых примерах данной курсовой работы имеются подтверждения выполненных тестов.

\subsection{Рекомендации по применению}

\textbf{Когда использовать полный перебор:}
\begin{enumerate}
\item Малая размерность задачи: $n \leq 8-10$ работников
\item Требуется гарантированная оптимальность: критические системы, где каждая единица стоимости значима
\item Разовые вычисления: когда можно позволить себе секундное ожидание
\item Валидация других алгоритмов: для проверки качества приближённых методов
\item Образовательные цели: демонстрация принципа исчерпывающего поиска
\end{enumerate}

\textbf{Когда использовать жадный алгоритм:}
\begin{enumerate}
\item Большая размерность: $n > 10$, особенно $n \geq 50-100$
\item Требуется быстрое решение: реального времени или интерактивные системы
\item Приближённое решение допустимо: когда 5-15\% отклонение приемлемо
\item Ограниченные вычислительные ресурсы: мобильные устройства, встраиваемые системы
\item Предварительный анализ: быстрое получение "грубого" решения для оценки
\end{enumerate}

\textbf{Вывод:} выбор алгоритма определяется компромиссом между точностью и скоростью. Для малых n предпочтителен полный перебор, для больших n - жадный алгоритм. Реализованная программа демонстрирует оба подхода, позволяя пользователю или системе автоматически выбирать подходящий метод в зависимости от размера задачи.

\section{ИНСТРУКЦИЯ ПОЛЬЗОВАТЕЛЯ}
\addcontentsline{toc}{section}{ИНСТРУКЦИЯ ПОЛЬЗОВАТЕЛЯ}

Программа "Assignment Problem Solver" предназначена для решения классической задачи о назначениях двумя различными алгоритмами: методом полного перебора (точное решение) и жадным алгоритмом (приближённое решение). Программа автоматически определяет оптимальный метод решения в зависимости от размера входной матрицы и сохраняет результаты в текстовый файл.

Перед началом работы пользователю необходимо подготовить входной файл \texttt{input.txt}, содержащий квадратную матрицу стоимостей. Формат файла:

\begin{verbatim}
n
a11 a12 ... a1n
a21 a22 ... a2n
...
an1 an2 ... ann
\end{verbatim}

\textbf{Пример файла test.txt:}
\begin{verbatim}
3
9 2 7
6 4 3
5 8 1
\end{verbatim}

\textbf{Требования к данным:}
\begin{itemize}
\item Первая строка - целое число n (размер матрицы, $2 \leq n \leq 1000$);
\item Последующие n строк: по n целых чисел, разделённых пробелами;
\item Все числа должны быть неотрицательными;
\item Матрица должна быть квадратной.
\end{itemize}

Выходные данные сохраняются в текстовом файле \texttt{result.txt}.

\section{ТЕСТОВЫЕ ПРИМЕРЫ}
\addcontentsline{toc}{section}{ТЕСТОВЫЕ ПРИМЕРЫ}

\subsection{Тест 1}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{media/image3.png}
\caption{Тест 1 - Визуализация работы программы}
\label{fig:test1}
\end{figure}

\textbf{Выбор входного файла:} \texttt{Test1\_input.txt}

\textbf{Входные данные:}
\begin{verbatim}
3
9 2 7
6 4 3
5 8 1
\end{verbatim}

\textbf{Выходные данные:} \texttt{Result.txt}
\begin{verbatim}
ASSIGNMENT PROBLEM SOLUTION
============================
Matrix size: 3x3
Cost matrix:
9 2 7
6 4 3
5 8 1

--- GREEDY ALGORITHM ---
Greedy algorithm:
Total cost: 10
Assignment: W1->J2, W2->J3, W3->J1

--- BRUTE FORCE ALGORITHM ---
Brute force algorithm:
Total cost: 9
Assignment: W1->J2, W2->J1, W3->J3

--- COMPARISON ---
Greedy cost: 10
Brute force cost: 9
Brute force found better solution by 1

=== END OF REPORT ===
\end{verbatim}

\subsection{Тест 2}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{media/image4.png}
\caption{Тест 2 - Визуализация работы программы}
\label{fig:test2}
\end{figure}

\textbf{Выбор входного файла:} \texttt{Test2\_input.txt}

\textbf{Входные данные:}
\begin{verbatim}
4
82 83 69 92
77 37 49 92
11 69 5 86
8 9 98 23
\end{verbatim}

\textbf{Выходные данные:} \texttt{Result.txt}
\begin{verbatim}
ASSIGNMENT PROBLEM SOLUTION
============================
Matrix size: 4x4
Cost matrix:
82 83 69 92
77 37 49 92
11 69 5 86
8 9 98 23

--- GREEDY ALGORITHM ---
Greedy algorithm:
Total cost: 140
Assignment: W1->J3, W2->J2, W3->J1, W4->J4

--- BRUTE FORCE ALGORITHM ---
Brute force algorithm:
Total cost: 140
Assignment: W1->J3, W2->J2, W3->J1, W4->J4

--- COMPARISON ---
Greedy cost: 140
Brute force cost: 140
Both algorithms found optimal solution!

=== END OF REPORT ===
\end{verbatim}

\subsection{Тест 3}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{media/image5.png}
\caption{Тест 3 - Визуализация работы программы}
\label{fig:test3}
\end{figure}

\textbf{Выбор входного файла:} \texttt{Test3\_output.txt}

\textbf{Входные данные:}
\begin{verbatim}
5
12 7 9 7 9
8 9 6 6 6
7 17 12 14 9
15 14 6 6 10
4 10 7 10 9
\end{verbatim}

\textbf{Выходные данные:} \texttt{Result.txt}
\begin{verbatim}
ASSIGNMENT PROBLEM SOLUTION
============================
Matrix size: 5x5
Cost matrix:
12 7 9 7 9
8 9 6 6 6
7 17 12 14 9
15 14 6 6 10
4 10 7 10 9

--- GREEDY ALGORITHM ---
Greedy algorithm:
Total cost: 35
Assignment: W1->J2, W2->J3, W3->J1, W4->J4, W5->J5

--- BRUTE FORCE ALGORITHM ---
Brute force algorithm:
Total cost: 32
Assignment: W1->J2, W2->J3, W3->J5, W4->J4, W5->J1

--- COMPARISON ---
Greedy cost: 35
Brute force cost: 32
Brute force found better solution by 3

=== END OF REPORT ===
\end{verbatim}

\section*{ЗАКЛЮЧЕНИЕ}
\addcontentsline{toc}{section}{ЗАКЛЮЧЕНИЕ}

В ходе выполнения курсовой работы была разработана программная система для решения классической задачи о назначениях с использованием двух различных алгоритмических подходов. Основная задача состояла в создании корректной математической модели и реализации как точного метода полного перебора, так и приближённого жадного алгоритма. На основе спроектированных структур данных и объектно-ориентированной архитектуры была создана устойчивая система обработки матриц стоимостей произвольной размерности.

Исследовательский процесс был систематизирован за счёт сравнительного анализа временной и пространственной сложности алгоритмов, что позволило объективно оценить границы их практической применимости. Реализация алгоритма полного перебора продемонстрировала гарантированное нахождение оптимального решения для задач малой размерности, в то время как жадный алгоритм показал высокую эффективность при работе с матрицами значительного размера, обеспечивая разумный компромисс между точностью и быстродействием.

Проведённое тестирование подтвердило корректность работы всех модулей программы: загрузка данных из файлов, выполнение вычислительных алгоритмов, сравнение результатов и сохранение отчётов. Разработанная программа может служить как образовательным инструментом для демонстрации принципов комбинаторной оптимизации, так и практическим решением для задач распределения ресурсов в реальных приложениях. Работа показала, что выбранные алгоритмические решения и архитектурные подходы обеспечивают надёжность, расширяемость и удобство использования программной системы для решения широкого класса оптимизационных задач.

\section*{ПРИЛОЖЕНИЕ}
\addcontentsline{toc}{section}{ПРИЛОЖЕНИЕ}

Исходный код программы, тестовые данные и данная работа доступны в репозитории GitHub: \\
\url{https://github.com/[ВАШ_НИК]/assignment-problem-solver}

\section*{СПИСОК ЛИТЕРАТУРЫ}
\addcontentsline{toc}{section}{СПИСОК ЛИТЕРАТУРЫ}

\begin{enumerate}
\item Э. Рейнгольд, Ю. Нивергельт, Н. Део, Комбинаторные алгоритмы, Мир, 1980 г.
\item А. Кофман, Введение в прикладную комбинаторику, Наука, 1975 г. (с. 405-415)
\end{enumerate}

\end{document}